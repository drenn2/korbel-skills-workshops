---
title: "Pardee Skills Workshop: Data Management, Manipulation, and Visualization with R"
author: "Mickey Rafa"
date: "Spring 2018"
output:
  html_notebook:
    toc: yes
    fig.width: 7
    fig.align: "center"
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: 3
    fig.width: 7
    fig.align: "center"
    code_folding: hide
---

```{r setup, include=FALSE, echo=TRUE}
library(tidyverse)      #for data management, manipulation, visualization, and exploratory data analysis
```

# Introduction

# Overview

`dplyr` is a package designed to standardize the data management and manipulation process in R. `dplyr` has a small set of functions (which may be more easily thought of as **verbs**) which are designed to help users navigate the most common challenges of data manipulation. These are:  

*  `distinct()` returns the unique values of a variable.  
*  `filter()` returns the observations, or rows, based on logic that you determine.    
*  `arrange()` changes the ordering of the rows.
*  `mutate()` adds new variables that are functions of existing variables. These are often referred to as "derived" variables.  
*  `summarise()` reduces multiple values down to a single summary.  

We will use R's `ggplot2` package to create exploratory visualizations of data. This will give you the building blocks for creating beautiful visualizations.  

Combining datasets is often critical for data analysis. This lesson will briefly survey of dataset merging and demonstrate the use of two `dplyr` functions: `left_join()` and `inner_join()`.

`dplyr` and `ggplot2` can be thought of as supplying a grammar for data manipulation and data visualization, respectively. 

# Learning objectives  

By the end of this lesson, you will be familiar with the use of each of the above mentioned functions.

# The Gapminder dataset  

We'll learn the main `dplyr` variables using the **gapminder** dataset. 

```{r read_gapminder, include=TRUE, echo=TRUE}
library(gapminder)                  #for the gapminder dataset

gapminder <- gapminder::gapminder
str(gapminder)
```

Looking at the general structure of the dataset tells us a few important insights:

*  Rows and columns
*  Variable types: factor (categorical) vs. numeric

```{r summary_gapminder, include=TRUE}
summary(gapminder)
```

# dplyr's main functions  

## distinct()  

To begin our anlaysis, let's look at the years that are available in the gapminder dataset. There are many ways to do this, but I'll use the `distinct()` function from `dplyr`.

```{r distinct_years, include=TRUE}
gapminder %>% 
  distinct(year)
```

This shows us that we have data that are in five-year increments from 1952 to 2007. 

Before we move on, let's take a closer look at the code above, because it uses a style that we will be fluent in by the end of this session. This code uses "**piping**" (the %>%), which is a coding style that makes code more readable and easier to troubleshoot. The "pipe" (%>%) tells R to take the object to the left of the pipe and feed it action following the pipe. The code above can be read as:

*  Feed the `gapminder` dataframe into the `distinct()` function  
*  Return the distinct or unique values in the `year` column  

When reading your code, you can think of the **pipe operator (%>%)** as "THEN". To use the above example, take the gapminder dataframe, **THEN** return the distinct values in the year column. 

Think of this as the Earnest Hemingway style of writing code in R (simple, yet powerful). This simple example may not convey the full utility of piping, but that will be clear by the end of the session. 

## filter() 

The `filter()` function allows you to subset your data by values of the variables in your dataset. For instance, we can filter the gapminder dataframe to look at only the values in the year 2007.  

```{r filter_year, include=TRUE}
gapminder %>% 
  filter(year == 2007)
```

This returns the 142 records (or rows) that are in the year 2007. In the `filter()` function, you 

What's the double equal sign ("**==**") mean? This is a **boolean equal**, meaning that it is evaluating whether the equation returns a TRUE or FALSE. The above code can be read as "filter, return rows in which the variable year equals 2007".

You can also use the `filter()` command on multiple conditions, too. Just separate the conditions with a comma. The code below takes the gapminder dataframe, and filters the data in which the **country** is South Africa and the **year** is 2007. 

```{r filter_year_country, include=TRUE}
gapminder %>% 
  filter(country == 'South Africa',
         year == 2007)
```

This shows that the dataset has only one occurrence of South Africa in 2007. Note that in `dplyr`, separating arguments with a comma allows you to combine multiple logical expressions. How would you read the above code aloud?

**One thing to keep in mind** -- your data object remains unchanged, unless you assign the `filter()` to a new object. This is a way to view or subset your data without changing the original dataframe.  

## arrange()  

The `arrange()` function sorts your data -- a very common thing to do in an exploratory data analysis. Let's arrange the gapminder data by life expectancy (the variable is called **lifeExp**).  

```{r arrange_lifeExp, include=TRUE}
gapminder %>% 
  arrange(lifeExp)
```

This shows us that Guinea in 1972 is the lowest life expectancy in the dataset. By default, the `arrange()` function sorts your data in ascending order. What if we want to sort the data by the largest GDP per capita (variable is **gdpPercap**) in the dataset? 

```{r arrange_desc_gdppercap, include=TRUE, echo=TRUE}
gapminder %>% 
  arrange(desc(gdpPercap))
```

You can also arrange by multiple variables with the `arrange()` function. Let's say that you want to arrange the gapminder data by year and by life expectancy. Try using `gapminder %>% arrange(year, lifeExp)`. What do you see?

**Quiz**:

*  Let's put the `filter()` and `arrange()` functions together. I'd like to see the **average life expectancy of all countries in the year 2002, sorted in ascending order**. How might we do that?  

```{r filter_arrange_combined, include=FALSE, echo=FALSE}
gapminder %>% 
  filter(year == 2002) %>% 
  arrange(lifeExp)
```

## mutate()  

In data analysis, it's common to want to create or *derive* new variables from your original dataset. This is done with the `dplyr::mutate()` function. For example, you might want to create a variable that is the distance in time from the beginning of the dataset. This is a typical derived variable used in regression modeling.

For these new variables, let's save this as a new data object.

```{r gapminder_2, include=TRUE}
gapminder <- gapminder %>% 
  mutate(time_dist = year - 1952)

print(gapminder)
```

**Quiz**:  

*  Use `dplyr::mutate()` to create two other variables -- **GDP** and **population (in millions)**.  

```{r gapminder_2_quiz, include=TRUE}
gapminder <- gapminder %>% 
  mutate(gdp = gdpPercap * pop,
         pop = pop/1000000)
```

Note that just like the `filter()` function, which allows you to have multiple conditions, you can also create multiple new variables by using a comma within `mutate()`.

**Quiz**:

*  What are the countries with the largest total GDP in 2007?  

```{r filter_gdp, include=TRUE}
gapminder %>% 
  filter(year == 2007) %>% 
  arrange(desc(gdp))
```

## summarise()   

In your own anlayses, you've probably calculated summary stats for variables. Using the gapminder dataset as an example, what is the mean life expectancy from the dataset? This is where `summarise()` function comes in handy. Think of `summarise()` as useful when you want to collapse many rows in a smaller number of rows.

The `summarise()` function follows the same syntax as `mutate()`, which is used for creating or deriving new variables, too. The difference is that `summarise()` is creating a new **grouped** variable with an **aggregate function*.*

```{r summarise_ex1, include=TRUE}
gapminder %>% 
  summarise(meanlifeExp = mean(lifeExp))
```

This code is returning the average life expectancy for all countries and years in the dataset. 

This may be useful for your research question, but it is far more likely that you'll want to summarise a variable like **lifeExp** by a **grouping variable**. For instance, what is the average life expectancy from this dataset **by year**? Anytime you want to summarise a variable "BY" another variable, `dplyr::group_by()` comes in handy.

```{r summarise_ex2, include=TRUE}
gapminder %>% 
  group_by(year) %>% 
  summarise(meanlifeExp = mean(lifeExp))
```

The above code groups the gapminder dataset by the **year** variable and computes the average life expectancy per year. This shows the gradual advancement in global average life expectancy over time. Pretty neat!

The gapminder dataset begs the question: how has the average life expectancy changed over time and across continents? Said another way, how has average life expectancy changed **BY** year and **BY** continent? Just like previous functions that we've learned (such as `filter()` and `mutate()`), you can group your data by multiple conditions with comma.

```{r summarise_ex3, include=TRUE}
gapminder %>% 
  group_by(year, continent) %>% 
  summarise(meanlifeExp = mean(lifeExp))
```

With this code, we're able to see some strong variability in average life expectancy by continent. This is worth exploring more closely. Let's re-write the above code and save it as a new dataframe for further exploration. I'd like to add a few additional summary calculations:  

*  The total population (`sum()`)  
*  The mean GDP per capita (`mean()`)  
*  The count of countries in the dataset in each continent/year pair (`n()`)

```{r summarise_ex3_save, include=TRUE}
gapminder_by_year_continent <- gapminder %>% 
  group_by(year, continent) %>% 
  summarise(meanlifeExp = mean(lifeExp),
            totalPop = sum(pop),
            meanGdpPercap = mean(gdpPercap),
            count_countries = n())
```

**Quiz**:

*  Which continent had the lowest mean life expectancy in 1982?  
*  How many countries in Oceania are in the dataset in 2007?  
*  What was Africa's mean GDP per capita value in 1987?  

Note that `group_by()` is most commonly combined with `summarise()`, but you can also use it with `mutate()`. For instance, you could group the gapminder dataset by continent and produce within continent rankings for life expectancy. There's so much that you can do with the `dplyr` verbs working together. 

# Visualization with ggplot2  

`ggplot2` is a tremendously flexible visualization package in R. "Gg" stands for the "grammar of graphics", which is an extremely powerful set of language tools that help define elements of a visualization. 

There are three primary elements of ggplot graphics:  

1.  The **data** that you want to visualize.    
2.  The **aesthetics** of the graphic, or the variables that make up the visualization.  
3.  The **geoms**, or the type of visualization that you want to create. 

There are many, many types of visualizations supported, so mastering these elements unleashes a ton of possibilities.[^1] We will come back to each of the elements for every viz that we create.

Let's begin with scatterplots. These are visualizations that show the relationship between two variables. Let's create a viz of the relationship between GDP per capita and life expectancy in 2007:  

*  First, using the **piping** that we learned previously, filter the gapminder data to only include the 2007 rows. *  Then, let's start defining the ggplot elements.  

[^1]: This is a useful reference for learning about all of the geom options in ggplot. This might look overwhelming, but it is something that you pick up more as you move into more exotic visualization types. (http://ggplot2.tidyverse.org/reference/#section-layer-geoms)

```{r gapminder_scatter_1, include=TRUE, echo=TRUE}
gapminder %>%                           #DATA
  filter(year == 2007) %>%              #DATA
  ggplot(aes(x=gdpPercap,               #AESTHETICS
                 y=lifeExp)) +          #AESTHETICS
  geom_point()                          #GEOM
```

Let's examine the code before we unpack the graphic. You'll recall from the `dplyr` functions that we've learned so far that **piping** is an effective way to write code that flows between functions. First, we piped the gapminder data to `filter()`, then we piped that filtered dataframe to ggplot(). Within ggplot's functions (`ggplot()` and `geom_point()`) we use a plus sign. Think of ggplot as a canvas where the graphic is built by the addition of elements. First, we defined the aesthetics (`aes()`), or what we wanted to graph. Then, we added the **geom** to the aesthetic, which tells ggplot the type of graphic that we wanted to create. We'll get more practice with ggplot's three elements -- data, aesthetics, and geoms -- as we go.

The graphic shows some interesting behavior:  

*  Many countries are clustered below $10,000 per capita, but the range of average life expectancy is quite dramatic. 
*  There is a saturating behavior in the data, meaning that at a certain average life expectancy (about 75 and up), income does not seem to have a strong relationship with life expectancy outcomes.  
*  There appears to be a strong logarithmic relationship between these variables, meaning that the x-axis has a scale that increases in orders of magnitude (1,000 - 10,000 - 100,000).  

The above graphic is very interesting. However, the gapminder dataset has additional information that could be put to use to extract more value from this viz. Let's see what this looks like when you color each point by the continent. To do this, you add `color=continent` to the aesthetic.

```{r gapminder_scatter_2, include=TRUE, echo=TRUE}
gapminder %>%                         #DATA
  filter(year == 2007) %>%            #DATA
  ggplot(aes(x=gdpPercap,             #AESTHETIC
             y=lifeExp,               #AESTHETIC    
             color=continent)) +      #AESTHETIC
  geom_point()                        #GEOM
```

This illustrates that many of the poorest performing countries are located in Africa.

**On your own**:

*  Set `color="blue"` in the previous code. What do you see? Why do you think that is happening?  

There are dozens of ways that you can customize `ggplot` visualizations. With enough practice, you can have total control of the visualizations that you create. Let's start with two very common and useful customizations:  

1.  Putting the x-axis on a logarithmic scale, and  
2.  Changing the axis labels.

To transform the x-axis to a logarithmic scale, simply add `scale_x_log10()` to the previous visualization's code. This will compress the x-axis and show a more linear relationship than the previous graphic.

```{r gapminder_scatter_3, include=TRUE, echo=TRUE}
gapminder %>%                             #DATA
  filter(year == 2007) %>%                #DATA
  ggplot(aes(x=gdpPercap,                 #AESTHETIC
                 y=lifeExp,               #AESTHETIC
                 color=continent)) +      #AESTHETIC
  geom_point() +                          #GEOM
  scale_x_log10()                         #CUSTOMIZING ELEMENT
```

The `labs()` command in ggplot allows users to take control of the axis labels.  

```{r gapminder_scatter_4, include=TRUE, echo=TRUE}
gapminder %>% 
  filter(year == 2007) %>% 
  ggplot(aes(x=gdpPercap,
                 y=lifeExp,
                 color=continent)) + 
  geom_point() + 
  scale_x_log10() + 
  labs(x='GDP per capita (logged)',
       y='Average life expectancy')
```

**On your own**:  

*  Search Google to find out how to add a title to your ggplot graphic.  
*  Create another scatterplot with another variable combination from the gapminder dataset.  

## Visualizing summary data 

Let's go back to the `gapminder_by_year_continent` dataframe that we created earlier. This is a dataframe with summary stats by continent and year. We'll use this data to create a line graph showing the average life expectancy by continent over time.

**Quiz**:  

*  We have the **data** element already (`gapminder_by_year_continent`). What are the other two ggplot elements that we need to create a graphic?  
*  What would be our `x=` and `y=` arguments in the aesthetic?  

```{r summary_ggplot_viz1, include=TRUE, echo=TRUE}
gapminder_by_year_continent %>% 
  ggplot(aes(x=year,
             y=meanlifeExp,
             color=continent)) + 
  geom_line()
```

This plot shows us very clearly the gap between Africa and all other continents in life expectancy over time.

**On your own**:  

*  Remove the `color=continent` argument from the previous plot? What happens, and why?  
*  Plot another one of the summarised variables from the `gapminder_by_year_continent` dataframe over time.  
*  Using the `gapminder` dataframe, `filter()` the data on a country of your choice, and visualize a line plot over time (any variable you'd like).  

```{r zambia_life_expectancy, include=FALSE}
ex_country <- c('Zambia', 'China', 'Argentina', 'Bulgaria')

gapminder %>% 
  filter(country %in% ex_country) %>% 
  ggplot(aes(x=year,
             y=lifeExp,
             color=country)) + 
  ggtitle('Average life expectancy at birth, select countries',
          subtitle = '1957-2007') + 
  labs(x='Year',
       y='Life expectancy at birth (years)',
       caption='Gapminder dataset',
       color='') + 
  geom_line() + 
  theme(legend.position = 'top')
```

# Re-cap  

If you've stayed with us this long, you've learned quite a few data management, manipulation, and visualization skills. The `dplyr` package has a collection of simple, yet powerful management and analysis tools, such as:  

*  `distinct()` returns the unique values of a variable.  
*  `filter()` picks cases based on their values.  
*  `arrange()` changes the ordering of the rows.
*  `mutate()` adds new variables that are functions of existing variables. These are often referred to as "derived" variables.  
*  `summarise()` reduces multiple values down to a single summary.  
*  `group_by()` -- when combined with the `summarise()` function -- allows you to compute summary statistics by grouping variables.  

You've also learned how to use `ggplot2` to visualize your data, by specifying your **data**, **aesthetics**, and **geom**. You've learned two of the most common types of visualizations, the scatterplot and line plot, with `geom_point()` and `geom_line()`, respectively. You've also learned how to make small customizations to your graphics to improve the effectiveness and the amount of information contained in your visualizations, such as adding axis labels and a title, coloring your plot by another variable, and changing the scale of an axis. There are endless options/customizations within `ggplot2`, and it's an incremental process to reach mastery. (Hopefully, a future Pardee Methods Workshop will focus exclusively on visualizing data in R!)

There are many other `dplyr` functions and ggplot customizations that we couldn't cover. 

*  `dplyr::select()` returns the variables, or columns, that you wish to work with.  
*  `dplyr::rename()` allows you to change a variable name.  
*  `dplyr::left_join()` and `dplyr::inner_join()` are the most common functions to join two related dataframes.  
*  And there are dozens of other ggplot geoms and themes to take complete control over your graphics.  



# Analysis of U.S. Supreme Court data  

I am providing a dataset on all U.S. Supreme Court decisions since 1946, which are organized by case and justice vote.[^2] I'd like for you to put together the skills that you've learned in this session to do some exploratory analysis of the data. 

First, let's look at the data together. Read in the data with the `read.csv()` function, and save it to an object called "sup_court". Then, use the `glimpse()` function to peek at the sup_court object.

[^2]: http://scdb.wustl.edu/data.php

```{r glimpse_sup_court, include=TRUE, echo=TRUE}
sup_court <- read.csv('supreme_court_1946_2018.csv')

glimpse(sup_court)
```

Explore the dataset on your own, and see what you can find! Try to ask a question of the dataset and come up with an answer. In case you want some examples to guide you, you might ask...

*  Which Chief Justice has presided over the most cases since 1946? Which has heard the fewest?  
*  How many decisions has Justice Gorsuch made in his short tenure on the bench? How often has he cast a dissenting opinion? How often has he made decisions that would be considered conservative? What types of cases has he heard most often to this point? (hint: Gorsuch can be found using the justiceName variable with **NMGorsuch**.) 
*  Justice Kennedy has a reputation as being the swing voter on the Supreme Court. How might you test this conventional wisdom with this dataset? (hint: you might consider using the **majVotes** and **minVotes** variables for this question) 
*  Which justice has heard the most Supreme Court Cases since 1946? (hint: the justice is the primary unit of analysis) 
*  Justice Scalia was known as a staunch conservative presence on the bench. Were there some issues that he leaned more centrist? (hint: `group_by()` and `summarise()` would come in handy here, yet again)  
*  What are the trends in the types of case heard by term? (hint: **BY term**)


```{r sup_court_q1, include=FALSE}
sup_court %>% 
  group_by(chief) %>% 
  summarise(count_cases = n()) %>% 
  arrange(desc(count_cases))
```

```{r sup_court_q2_1, include=FALSE}
sup_court %>% 
  filter(justiceName == 'NMGorsuch') %>% 
  group_by(justiceName) %>% 
  summarise(count_cases = n())
```

```{r sup_court_q2_2, include=FALSE}
sup_court %>% 
  filter(justiceName == 'NMGorsuch') %>% 
  group_by(justiceName, majorityName) %>% 
  summarise(count_cases = n())
```

```{r sup_court_q2_3, include=FALSE}
sup_court %>% 
  filter(justiceName == 'NMGorsuch') %>% 
  group_by(justiceName, directionName) %>% 
  summarise(count_cases = n())
```

```{r sup_court_q2_4, include=FALSE}
sup_court %>% 
  filter(justiceName == 'NMGorsuch') %>% 
  group_by(justiceName, issueAreaName) %>% 
  summarise(count_cases = n()) %>% 
  mutate(perc_cases = round(count_cases / sum(count_cases) * 100, 1)) %>% 
  arrange(desc(perc_cases))
```

```{r sup_court_q3, include=FALSE}
sup_court %>% 
  filter(majVotes == 5,
         minVotes == 4) %>% 
  group_by(justiceName, majorityName) %>% 
  summarise(count_cases = n()) %>% 
  mutate(perc_cases = round(count_cases / sum(count_cases) * 100, 1)) %>% 
  arrange(desc(perc_cases))
```

```{r sup_court_q4, include=FALSE}
sup_court %>% 
  group_by(justiceName) %>% 
  summarise(count_cases = n()) %>% 
  arrange(desc(count_cases))
```
